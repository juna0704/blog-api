====================================================
ðŸ“„ docs/SECURITY.md â€” Security Architecture & Best Practices
====================================================

# ðŸ”’ Security Documentation â€” Blog API

This document covers all security mechanisms implemented in the Blog API backend, including:

- Authentication & token security
- Authorization & role enforcement
- Input validation & sanitization
- Session and refresh token handling
- Rate limiting
- Transport & cookie security
- Password hashing
- Database safety
- Common attack vectors & mitigations

The system follows modern security standards suitable for production environments.

---

====================================================

# ðŸ“˜ 1. Authentication Security

====================================================

The Blog API uses a **dual JWT token system**:

- **Access Token**

  - Short-lived
  - Sent via `Authorization: Bearer <token>`
  - Contains: `{ userId }`

- **Refresh Token**
  - Long-lived
  - **Stored in HttpOnly, SameSite=Strict cookie**
  - Stored _also_ in MongoDB for session validation
  - Used only at: `/auth/refresh-token`

## Why this design is secure?

### âœ” HttpOnly cookie

Prevents JavaScript from stealing refresh tokens via XSS.

### âœ” SameSite=Strict

Prevents CSRF attacks from external sites.

### âœ” Token stored in DB

A stolen refresh token is useless if not present in the DB.

### âœ” Access token short-lived

Limits impact if an access token is leaked.

---

====================================================

# ðŸ“˜ 2. Authorization Security

====================================================

Authorization is enforced by:

### **1. authenticate.ts**

- Verifies access token signature
- Detects:
  - Expired tokens â†’ `401`
  - Invalid tokens â†’ `401`
  - Missing tokens â†’ `401`

### **2. authorize.ts**

Checks if user role matches required roles:

```ts
authorize(['admin'])
authorize(['admin', 'user'])

If role mismatch â†’ 403 Forbidden.
âœ” Only admins can:
    Create, update, or delete blogs
    View all users
    Delete any user
âœ” Users cannot escalate to admin
Admin role is restricted by: WHITELIST_ADMINS_MAIL
If user is not in the whitelist â†’ cannot register as admin.

====================================================
# ðŸ“˜ 3. Password Security
====================================================
Passwords are secured via:
âœ” bcrypt hashing

const salt = await bcrypt.genSalt(10);
this.password = await bcrypt.hash(this.password, salt);
âœ” Enforced minimum length (6 characters)
âœ” Password never returned in API
âœ” Password comparison uses secure hashing

====================================================
# ðŸ“˜ 4. Input Validation & Sanitization
====================================================
The API uses:

âœ” express-validator
Every route validates:
    Email format
    Password strength
    Slug format
    MongoId validity
    Pagination parameters

âœ” Sanitization using DOMPurify + JSDOM
Blog content is sanitized before storage to prevent:
    XSS
    Script injection
    Malicious HTML payloads

âœ” Multer File Validation
Banner uploads are validated through:
    Size limits
    MIME type filtering
    Cloudinary sanitization

====================================================
# ðŸ“˜ 5. Rate Limiting
====================================================
Global rate limiting ensures bots and attackers cannot flood the server.

Implementation (express-rate-limit)
app.use(limiter);

Configured to:
    Limit requests per IP
    Block abusive clients
    Protect endpoints from DDoS & brute force attacks


====================================================
# ðŸ“˜ 6. Transport Security
====================================================
âœ” HTTPS enforced in production
Secure cookies require HTTPS:
secure: config.NODE_ENV === 'production'

âœ” Nginx reverse proxy recommended
In /docker/nginx.conf.
âœ” Helmet middleware enabled
app.use(helmet());
This includes protections against:
    XSS
    MIME sniffing
    Clickjacking
    DNS prefetch attacks
    Frame injection
```

====================================================

# ðŸ“˜ 7. Token Security

====================================================
Access Token Security
Signed using HS256
Contains minimal data (userId)
Short-lived (ACCESS_TOKEN_EXPIRY)
Verified on every protected request

Refresh Token Security
Stored only in HttpOnly cookies
Stored in DB
Unique per session
Deleted on logout
Checked before issuing new access token

ðŸ”’ Refresh Token Theft Protection
If an attacker steals the token:
It will not exist in database â†’ request denied
It cannot be accessed from JS (HttpOnly)
CSRF is prevented (SameSite=Strict)
Token rotation can be implemented easily (future enhancement)

====================================================

# ðŸ“˜ 8. Common Attack Vectors & Mitigation

====================================================
ðŸ›¡ XSS (Cross-Site Scripting)
Mitigated by:
DOMPurify sanitization
HTML escaping
HttpOnly cookies
Helmetâ€™s XSS filter

ðŸ›¡ CSRF (Cross-Site Request Forgery)
Mitigated by:
SameSite=Strict refresh token cookie
No sensitive operations allowed without Authorization header
Access token cannot be sent automatically by browser

ðŸ›¡ SQL/Mongo Injection
Mitigated by:
Mongoose query sanitization
express-validator checks
No string interpolation into queries

ðŸ›¡ Brute Force Attacks
Mitigated by:
express-rate-limit
bcrypt password hashing
No overly verbose authentication errors

ðŸ›¡ DDoS & Traffic Flood
Mitigated by:
Rate limiting
Compression
Lightweight controllers
Nginx as reverse proxy

ðŸ›¡ Insecure Direct Object Access (IDOR)
Mitigated by:
authenticate + authorize mandatory
Validation using .isMongoId()
Role enforcement
User cannot access other user's data unless admin

====================================================

# ðŸ“˜ 9. Logging & Monitoring Security

====================================================

Using Winston:

error.log for error stack traces

access.log for incoming requests

app.log for application events

Sensitive data (passwords, tokens) is never logged.

====================================================

# ðŸ“˜ 10. Deployment Security

====================================================

Recommended production setup:

Reverse proxy via Nginx

HTTPS enabled

API rate limits at both Nginx & Express

PM2 running in cluster mode

Environment variables stored in .env (never committed)

Docker container isolation

Database authentication enabled

====================================================

# ðŸ“˜ 11. Security Recommendations for Future Versions

====================================================
ðŸ”§ Token Rotation (Highly Recommended)
Rotate refresh tokens on every use.

ðŸ”§ IP & Device Tracking for Sessions

Store user-agent + IP with Token model.

ðŸ”§ 2FA / MFA Support

OTP or authenticator app.

ðŸ”§ Account Lockout after repeated login failures

Prevent brute force attempts.

ðŸ”§ Email verification flow

Prevent spam registrations.

ðŸ”§ Audit logging

Log admin operations for compliance.

ðŸ“˜ 12. Summary

This backend implements a robust security stack:

âœ” JWT access + refresh tokens
âœ” HttpOnly / SameSite cookies
âœ” Role-based access control
âœ” Password hashing
âœ” Strict validation
âœ” Sanitized input
âœ” Helmet protection
âœ” Rate limiting
âœ” DB-backed sessions
âœ” Strong logging
